######################################################################################################
#
######################################################################################################
#' Find set likely to contain the most probable category
#'
#' Function that that finds the set likely to contain the most probable multinomial category
#' @param r maximum cell count
#' @param k number of cells
#' @param P desired inclusion probability
#' @examples find_worstcases_chen86(100, 5, 0.80)
#' @export
find_worstcases_chen86 <- function(r, k, P, mc.cores = NULL) {
	N <- r * k
	nsim <- 1e4
	r_prime <- r
	probs <- rep(1/k, k)
	selected <- matrix(nrow = nsim, ncol = k)
	f <- function(filler, N, probs) {
		temp <- stats::rmultinom(N * 1.1, 1, probs)
		applied_temp <- apply(temp, 1, cumsum)
		found <- function(vect) {
			which(vect == r)
		}
		v <- apply(applied_temp, 2, FUN = found)
		col_stop <- min(unlist(v))
		return(rowSums(temp[,1:col_stop, drop = F]))
	}
	if (is.null(mc.cores)) {
		selected <- sapply(rep(NA, nsim), f, N, probs)
	} else {
		selected <- do.call('cbind',mclapply(rep(NA, nsim),f, N, probs, mc.cores = mc.cores))
	}
	if(k == 1) {
		selected <- matrix(selected, nrow = 1, ncol = nsim)
	}
	for(i in 1:(r+1)) {
		r_prime <- r - i + 1
		if(dim(selected)[1] == k) { # unsure if a change happened between R-4.0 and R-3.
			sel_prop <- mean(selected[1,] >= r_prime)
		} else {
			sel_prop <- mean(selected[,1] >= r_prime)
		}
		if(sel_prop >= P) {
			break
		}
	}
	r_prime
	return(list(r_prime = r_prime, P = sel_prop))
}

######################################################################################################
#
######################################################################################################
#' Update table
#'
#' Function that that updates a table containing info generated by `find_worstcases_chen86()`
#' @param r maximum cell count
#' @param k number of cells
#' @param P desired inclusion probability
#' @param save.table whether you want to save a table for faster computation
#' @param table.path where table gets saved; only matters if `save.table=T`
wc_updater_finder <- function(r, k, P, save.table = F, table.path = NULL, mc.cores = NULL) {
	# mypath <- "~/mps/speed_test/worst_case_table.Rds"
	# mypath <- "/ihome/lmentch/nkissel/mps/speed_test/worst_case_table.Rds"
	if(save.table) {
		if(is.null(table.path)) {
			mypath <- paste0(getwd(), '/', 'worst_case_table.Rds')
		} else {
			mypath <- paste0(table.path, '/', 'worst_case_table.Rds')
		}
		if(exists(mypath)) {
			worst_cases <- readRDS(mypath)
			where <- (worst_cases$r %in% r) & (worst_cases$k %in% k) & (worst_cases$P %in% P)
			is_in <- sum(where)
		} else {
			is_in <- 0
		}
	} else {
		is_in <- 0
	}
	if(!exists('worst_cases')) {
		worst_cases <- data.frame(matrix(ncol = 4, nrow = 0))
		colnames(worst_cases) <- c('r','k','P','r_prime')
	}


	if(is_in == 1) {
		return(list(r_prime = worst_cases$r_prime[where], P = P))
	} else {
		curr_rows <- nrow(worst_cases)
		t <- find_worstcases_chen86(r = r, k = k, P = P, mc.cores = mc.cores)
		worst_cases[curr_rows + 1, 1] <- r
		worst_cases[curr_rows + 1, 2] <- k
		worst_cases[curr_rows + 1, 3] <- P
		worst_cases[curr_rows + 1, 4] <- t$r_prime
		if(save.table) saveRDS(worst_cases, file = mypath)
		return(list(r_prime = t$r_prime, P = P))
	}
}
